# 端到端延迟测试待验证项

## 背景

测试环境：
- 游戏电脑 → 显卡复制输出 → 2K 144Hz显示器 + 美乐威采集卡
- 本机（采集卡PCIE） → 串口 → ESP32 → USB鼠标 → 游戏电脑

实测结果：
- 采集延迟（144Hz）：~5ms（注释代码测得）
- 串口往返（10次）：18ms，平均1.8ms/次
- **端到端总延迟：20-30ms**（反应测试网页）

理论 vs 实际差距：~10-20ms 来源不明

---

## 待验证项

### 1. 美乐威采集延迟细分

**状态**：⏳ 待测试

**测试方法**：启用 `MWCaptureWrapperPRO.cs` 第325-335行的注释代码

```csharp
LibMWCapture.MWGetDeviceTime(m_channel_handle, ref now_tm);
LibMWCapture.MWGetVideoFrameInfo(m_channel_handle, video_buffer_info.iNewestBuffering, ref video_frame_info);
System.Diagnostics.Debug.WriteLine($"时间: " +
    $"软硬总共{(float)(now_tm - video_frame_info.allFieldStartTimes[0]) / 10000}ms,");
```

**需要记录**：
- [ ] `allFieldStartTimes[0]` - 源帧开始时间
- [ ] `allFieldBufferedTimes[0]` - 帧缓冲完成时间
- [ ] `now_tm` - 当前设备时间
- [ ] 计算各阶段耗时

**疑问**：
- 截取中心640×640时，`allFieldBufferedTimes[0]` 是否为-1？
- 如果为-1，说明截取时源帧还没完全缓冲，这是正常的低延迟行为

---

### 2. 低延迟模式配置验证

**状态**：✅ 已确认配置正确

**当前代码配置**（MWCaptureWrapperPRO.cs）：

| 参数 | 当前值 | 说明 |
|------|--------|------|
| 通知类型 | `MWCAP_NOTIFY_VIDEO_FRAME_BUFFERING` | 帧开始缓冲时通知（低延迟） |
| 帧标识 | `iNewestBuffering` | 获取正在缓冲的帧（低延迟） |
| `cyParitalNotify` | **0** | 等整帧完成后触发capture_event |
| DMA等待 | `INFINITE` | 无限等待，DMA传输很快 |

**官方LowLatency示例对比**：

| 参数 | Normal模式 | LowLatency模式 | 当前代码 |
|------|-----------|---------------|----------|
| 通知类型 | `FRAME_BUFFERED` | `FRAME_BUFFERING` | `FRAME_BUFFERING` ✓ |
| 帧标识 | `iNewestBuffered` | `iNewestBuffering` | `iNewestBuffering` ✓ |
| `cyParitalNotify` | 0 | **64** | **0** |

**结论**：
- `cyParitalNotify=64` 用于“边传输边处理”场景（如视频编码）
- YOLO检测需要完整图像，`cyParitalNotify=0` 是正确设置
- 当前配置已经是最优，采集延迟~5ms符合预期

---

### 3. ESP32 USB HID 执行延迟

**状态**：⏳ 待测试

**已知**：
- 串口往返通信：1.8ms/次（仅包含收到确认，不含USB执行）

**待验证**：
- [ ] ESP32 USB描述符中的轮询间隔（bInterval）是多少？
  - 1ms = 1000Hz（最佳）
  - 8ms = 125Hz（默认值，可能是瓶颈）
- [ ] 从ESP32收到串口指令到USB HID报告发出的时间

**测试方法**：
1. 在ESP32固件中添加时间戳输出
2. 或使用USB协议分析器抓包

**ESP32固件相关代码位置**：检查USB描述符配置

---

### 4. 显卡输出同步性

**状态**：⏳ 待测试

**疑问**：
- 复制模式下，显示器和采集卡输出是否真正同步？
- 是否存在帧缓冲导致的额外延迟？

**待验证**：
- [ ] 游戏电脑是否开启VSync？
- [ ] NVIDIA控制面板/AMD设置中的"低延迟模式"是否启用？

**测试方法**：
- 关闭VSync后重新测试端到端延迟
- 启用NVIDIA "Ultra Low Latency Mode" 或 AMD "Anti-Lag"

---

### 5. 网页渲染管线延迟

**状态**：⏳ 待测试

**疑问**：
- 反应测试网页从"准备变色"到"实际像素上屏"的时间
- 浏览器的渲染管线延迟

**待验证**：
- [ ] 对比网页测试 vs 自己写的C#测试程序的延迟差异
- [ ] 如果差异大，说明网页渲染有额外延迟

**测试方法**：
- 用C#写一个简单的全屏颜色切换程序
- 对比同样的端到端延迟测试

---

## 延迟拆分估算表

| 环节 | 估算值 | 测量值 | 备注 |
|------|--------|--------|------|
| 显卡渲染+输出 | 0-7ms | ? | 取决于VSync |
| 采集卡（144Hz） | ~5ms | **5ms** | ✅ 已测得 |
| 准心检测 | <1ms | **0.2-0.4ms** | ✅ 已测得 |
| YOLO推理 | 8-10ms | **10.8-19.5ms** | ⚠️ 比测试程序慢 |
| 目标选择 | <1ms | **0.0ms** | ✅ 已测得 |
| 串口通信 | ~2ms | **3-4ms** | ✅ 已测得 |
| ESP32处理 | <1ms | ? | |
| USB HID轮询 | 1-8ms | ? | **可能是瓶颈** |
| **总计** | 15-20ms | **16-24ms** | |

---

### 6. YOLO推理性能差异

**状态**：⚠️ 待优化

**问题描述**：
- 测试程序（gprs - 测试模型用）：yolov8s-pose 推理 **8.7ms**
- 主项目：同样模型推理 **10.8-19.5ms**
- 差距：**2-10ms**

**已排除**：
- [x] .NET版本问题：从 net10.0 改为 net9.0，有改善但未完全解决

**可能原因**：
- 图像转换方式不同：
  - 测试程序：`Save→Stream→Image.Load()` （正确解析BGR格式）
  - 主项目：`WrapMemory<Rgb24>` （零拷贝，但BGR/RGB顺序可能不匹配）

**待验证**：
- [ ] 将主项目的 `ProcessYoloDetection` 改成测试程序的方式
- [ ] 测试是否能达到8.7ms
- [ ] 输出 `result.Speed.Inference` 对比 YoloSharp 内部测量的推理时间

**计时方式差异分析**：

| 程序 | 计时方式 | 说明 |
|------|----------|------|
| 测试程序 | `result.Speed.Inference` | YoloSharp内部Stopwatch，只测纯推理 |
| 主项目 | `Get_device_time()` | 采集卡硬件时钟，包含调用开销 |

可能的影响：
- `Get_device_time()` 调用本身有微小开销（需与硬件通信）
- 主项目测量的 `t1 → t2` 包含图像转换开销（`WrapMemory`）
- 测试程序 `result.Speed` 只测量纯推理时间

**相关代码位置**：
- 主项目：`ImageHelper.cs` 第67-89行 `ProcessYoloDetection`
- 测试程序：`gprs - 测试模型用/gprs/Form1.cs` 第221-229行

---

## 下一步行动

1. **优先级高**：检查ESP32 USB轮询间隔配置
2. **优先级中**：验证VSync设置
3. **优先级低**：对比网页 vs 原生程序延迟
4. **优先级低**：YOLO推理性能差异排查

---

## 更新日志

- 2026-01-21：创建文档，记录初始测试数据和待验证项
- 2026-01-21：确认采集卡低延迟配置正确，添加已研究问题总结

---

## 已研究问题总结

### 美乐威采集卡低延迟配置

#### 配置参数说明

| 参数 | 位置 | 当前值 | 说明 |
|------|------|--------|------|
| 通知类型 | `MWRegisterNotify` | `FRAME_BUFFERING` | 帧开始缓冲时通知（低延迟） |
| 帧标识 | `MWGetVideoBufferInfo` | `iNewestBuffering` | 获取正在缓冲的帧（低延迟） |
| `cyParitalNotify` | `MWCaptureVideoFrameToVirtualAddressEx` | **0** | DMA部分完成通知行数 |
| DMA等待 | `WaitForSingleObject` | `INFINITE` | 无限等待，DMA很快 |

#### `cyParitalNotify` 详解

**关键结论**：此参数基于**目标输出尺寸**（640x640），而非源帧（2K）。

```
源帧 2560x1440 逐行缓冲到板载内存
        │
        ▼ 当缓冲到第 960 行时（中心区域起始位置）
        │
    ┌───┴───┐
    │ DMA开始从中心区域传输
    │ 每传输 cyParitalNotify 行目标数据
    │ 触发一次 capture_event
    └───────┘
        │
        ▼ 若 cyParitalNotify=64，需要 640÷64≈10 次才能完成
```

**实际测试结果**：
- `cyParitalNotify=0`：while循环一次就跳出
- `cyParitalNotify=64`：while循环多次才跳出
- 两者软硬时间几乎没有变化

**结论**：
- `cyParitalNotify>0` 用于“边传输边处理”场景（如视频编码）
- YOLO检测需要完整图像，**设置为0是正确选择**
- 截取中心区域时，必须等源帧缓冲到中间位置（~3.3ms @ 144Hz）

#### 两种通知模式对比

| 模式 | 通知类型 | 帧标识 | 适用场景 |
|------|----------|--------|----------|
| 普通 | `FRAME_BUFFERED` | `iNewestBuffered` | 整帧完全缓冲后处理 |
| 低延迟 | `FRAME_BUFFERING` | `iNewestBuffering` | 帧开始缓冲时即可开始DMA |

#### SDK参考

- 官方示例：`SDKv3/Examples/Legacy_VC++/GUI/LowLatency`
- `CAPTURE_PART_LINE = 64`（定义在 LowLatencyDlg.h）

---

### 采集延迟实测结果

**测试环境**：2K 144Hz

**测得数据**：
- 采集卡软硬总延迟：**~5ms**
- 符合理论值（1/144Hz ≈ 6.9ms）

**结论**：采集部分配置已为最优，主要缺口在YOLO推理（10-20ms）。
